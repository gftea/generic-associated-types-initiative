<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generic Associated Types Initiative</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html">üëã Welcome</a></li><li class="chapter-item "><a href="updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="explainer/using.html">Using GATs</a></li><li class="chapter-item "><a href="explainer/required_bounds.html">Required bounds</a></li><li class="chapter-item "><a href="explainer/future_directions.html">Future directions</a></li></ol></li><li class="chapter-item "><a href="RFC.html">‚ú® RFC</a></li><li class="chapter-item "><a href="design-discussions/index.html">üí¨ Design discussions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/outlives-defaults.html">üí¨ Outlives defaults</a></li><li class="chapter-item "><a href="design-discussions/where-the-where-1.html">üí¨ Where does the where clause go?</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="design-discussions/where-the-where.html">Initial write-up</a></li></ol></li></ol></li><li class="chapter-item "><a href="FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Generic Associated Types Initiative</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/generic-associated-types-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generic-associated-types-initiative"><a class="header" href="#generic-associated-types-initiative">Generic Associated Types initiative</a></h1>
<!--
 Status badge advertising the project as being actively worked on. When the
 project has finished be sure to replace the active badge with a badge
 like: https://img.shields.io/badge/status-archived-grey.svg
-->
<p><img src="https://img.shields.io/badge/status-active-brightgreen.svg" alt="initiative status: active" /></p>
<h2 id="what-is-this"><a class="header" href="#what-is-this">What is this?</a></h2>
<p>This page tracks the work of the Generic Associated Types <a href="https://lang-team.rust-lang.org/initiatives.html">initiative</a>! To learn more about what we are trying to do, and to find out the people who are doing it, take a look at the <a href="./CHARTER.html">charter</a>. </p>
<h2 id="current-status"><a class="header" href="#current-status">Current status</a></h2>
<p>The following table lists of the stages of an initiative, along with links to the artifacts that will be produced by the start of that stage.</p>
<table><thead><tr><th>Stage</th><th>State</th><th>Artifact(s)</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Proposal</a></td><td>‚úÖ</td><td><a href="./CHARTER.html">Charter</a></td></tr>
<tr><td></td><td></td><td><a href="https://github.com/rust-lang/rust/issues/44265">Tracking issue</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/proposal.html">Experimental</a></td><td>‚úÖ</td><td><a href="./RFC.html">RFC</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/development.html">Development</a></td><td>ü¶Ä</td><td><a href="./explainer.html">Explainer</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/feature-complete.html">Feature complete</a></td><td>üí§</td><td>Stabilization report</td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/stages/stabilized.html">Stabilized</a></td><td>üí§</td><td></td></tr>
</tbody></table>
<p>Key:</p>
<ul>
<li>‚úÖ -- phase complete</li>
<li>ü¶Ä -- phase in progress</li>
<li>üí§ -- phase not started yet</li>
</ul>
<h2 id="how-can-i-get-involved"><a class="header" href="#how-can-i-get-involved">How Can I Get Involved?</a></h2>
<ul>
<li>Check for &quot;help wanted&quot; issues on this repository!</li>
<li>If you would like to help with development, please contact the <a href="./charter.html#membership">owner</a> to find out if there are things that need doing.</li>
<li>If you would like to help with the design, check the list of active <a href="./design-questions/README.html">design questions</a> first. </li>
<li>If you have questions about the design, you can file an issue, but be sure to check the <a href="./FAQ.html">FAQ</a> or the <a href="./design-questions/README.html">design-questions</a> first to see if there is already something that covers your topic.</li>
<li>If you are using the feature and would like to provide feedback about your experiences, please [open a &quot;experience report&quot; issue].</li>
<li>If you are using the feature and would like to report a bug, please open a regular issue.</li>
</ul>
<p>We also participate on <a href="https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits">Zulip</a>, feel free to introduce yourself over there and ask us any questions you have.</p>
<h2 id="building-documentation"><a class="header" href="#building-documentation">Building Documentation</a></h2>
<p>This repository is also an mdbook project. You can view and build it using the
following command.</p>
<pre><code>mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-updates"><a class="header" href="#-updates">‚úèÔ∏è Updates</a></h1>
<p>Lang-team initiatives give monthly updates. This section collects the updates from this initiative for posterity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2021-oct-lang-team-update"><a class="header" href="#2021-oct-lang-team-update">2021-Oct: Lang team update</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li>GATs are moving towards stabilization. Major blockers:
<ul>
<li>Resolving the <a href="updates/../design-discussions/outlives-defaults.html">default inference</a> question we discussed earlier (plan described below)</li>
<li>Resolving the <a href="updates/../design-discussions/where-the-where.html">syntax of where clauses</a></li>
<li>Explainer that covers common usage patterns</li>
<li>Documenting test coverage</li>
<li>Triage known bugs</li>
</ul>
</li>
<li>Since we landed various improvements, jackh726 has been monitoring bugs, many of them are general issues with rustc that come up somewhat more often for GATs</li>
</ul>
<h2 id="goals-for-this-month"><a class="header" href="#goals-for-this-month">Goals for this month</a></h2>
<ul>
<li>Implement default inference solution</li>
<li>Settle question of whre clause syntax</li>
<li>Finish explainer and issue triage</li>
</ul>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p>The general plan is to push Generated Associated types towards stabilization, but with the expectation that the current form has ergonomic pitfalls. You can think of it as an MVP to expose functionality. Towards that end we aim to write an explainer that highlights the current state of the feature, what it can do, and what it can't.</p>
<h2 id="resolving-the-question-of-where-clause-defaults"><a class="header" href="#resolving-the-question-of-where-clause-defaults">Resolving the question of where clause defaults</a></h2>
<p>Last month we discussed a potential defaulting scheme for <code>where Self: 'a</code> annotations. There were some unknowns, such as the &quot;false default&quot; rate -- i.e., cases where the default would trigger but you don't want it. To help gain more data, the plan is to implement the logic for adding a default, but instead of adding a default, we will require that the default be written explicitly. You can think of it as an extended &quot;well-formedness&quot; requirement.</p>
<p>This preserves future flexibility:</p>
<ul>
<li>Remove the error altogether</li>
<li>Add as a lint with a fix</li>
<li>Simply add the where clause by default, perhaps with an opt out</li>
</ul>
<p>The error message for this default will include instructions on (a) known workarounds if it is not desired and (b) an issue where folks can comment if they have codebases where the default was not helpful. This should enable us to gain some data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-associated-types-charter"><a class="header" href="#generic-associated-types-charter">&quot;Generic Associated Types&quot; Charter</a></h1>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<ul>
<li>Deliver an initial version of <a href="https://github.com/rust-lang/rfcs/pull/1598">generic associated types</a> feature.</li>
</ul>
<h2 id="membership"><a class="header" href="#membership">Membership</a></h2>
<table><thead><tr><th>Role</th><th>Github</th></tr></thead><tbody>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/owner.html">Owner</a></td><td><a href="https://github.com/jackh726/">jackh726</a></td></tr>
<tr><td><a href="https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html">Liaison</a></td><td><a href="https://github.com/nikomatsakis/">nikomatsakis</a></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-explainer"><a class="header" href="#-explainer">üìö Explainer</a></h1>
<blockquote>
<p>The &quot;explainer&quot; is &quot;end-user readable&quot; documentation that explains how to use the feature being deveoped by this initiative.
If you want to experiment with the feature, you've come to the right place.
Until the feature enters &quot;feature complete&quot; form, the explainer should be considered a work-in-progress.</p>
</blockquote>
<h2 id="-suboptimal-syntax-alert-"><a class="header" href="#-suboptimal-syntax-alert-">‚ö†Ô∏è Suboptimal syntax alert ‚ö†Ô∏è</a></h2>
<p>In general, the GAT feature is currently in a &quot;minimum viable product&quot; phase. That means that there are a number of places where the syntax is kind of clumsy, and more annotations are required than we would like to have. The explainer describes the feature that we are aiming to stabilize but you can see the <a href="./explainer/future_directions.html">Future Directions</a> section for some notes on the kinds of changes we would like to make.</p>
<h2 id="the-problem-in-a-nutshell"><a class="header" href="#the-problem-in-a-nutshell">The problem in a nutshell</a></h2>
<p>If you want to iterate over something in Rust, you might write the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
for elem in v.iter() { ... }
<span class="boring">}
</span></code></pre></pre>
<p>The <code>iter</code> method returns an iterator of references into the items in the vector. Conceptually, it looks something like this (the actual implementation works differently):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Vec&lt;T&gt; {
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { vec: self, position: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>where <code>Iter</code> is a struct that implements the <code>Iterator</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Iter&lt;'a, T&gt; {
    vec: &amp;'a Vec&lt;T&gt;,
    position: usize,
}

impl&lt;'a, T&gt; Iterator for Iter&lt;'a, T&gt; {
    type Item = &amp;'a T;

    fn next(&amp;mut self) -&gt; Option&lt;&amp;'a T&gt; {
        let i = self.position;
        if i &lt; self.vec.len() {
            self.position += 1;
            Some(&amp;self.vec[i])
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust's other collections also have similar <code>iter</code> methods that work the same way. You might wonder, why not have an <code>Iterable</code> trait, that encapsulates this pattern? Something like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item;
    type Iterator: Iterator&lt;Item = Self::Item&gt;;

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator;
}
<span class="boring">}
</span></code></pre></pre>
<p>Well, if you look closely at this trait, you'll see that it does't work. The type that an impl needs to provide for <code>Iterator</code> needs to be able to reference <code>'a</code>, the lifetime of the <code>self</code> parameter. But currently, it can't! That lifetime is not in scope:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterable for Vec&lt;T&gt; {
    type Item = &amp;'a T;
    //           ^^ 'a is not in scope here!
    type Iterator = Iter&lt;'a, T&gt;;
    //                   ^^ 'a is not in scope here!

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { vec: self, position: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="enter-generic-associated-types"><a class="header" href="#enter-generic-associated-types">Enter: generic associated types</a></h2>
<p>With generic associated types, associated types can have generic parameters. This makes it possible to model the <code>Iterable</code> trait by having the <code>Iterator</code> type take a generic parameter, <code>'a</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'a&gt;
    where
        Self: 'a; // &lt;-- see the &quot;required bounds&quot; section for more information

    type Iterator&lt;'a&gt;: Iterator&lt;Item = Self::Item&lt;'a&gt;&gt;
    where
        Self: 'a; // &lt;-- see the &quot;required bounds&quot; section for more information

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Given this trait definition, we can implement <code>Iterable</code> like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterable for Vec&lt;T&gt; {
    type Item&lt;'a&gt; = &amp;'a T
    where
        T: 'a; // &lt;-- see the &quot;required bounds&quot; section for more information

    type Iterator&lt;'a&gt; = Iter&lt;'a, T&gt;
    where
        T: 'a; // &lt;-- see the &quot;required bounds&quot; section for more information

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Iter&lt;'a, T&gt; {
        Iter { vec: self, position: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-gats"><a class="header" href="#using-gats">Using GATs</a></h1>
<p>Suppose I want to write a function that accepts any iterable and creates a vector by cloning its elements. I can now write such a thing like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn into_vec&lt;T&gt;(
    iterable: &amp;impl for&lt;'a&gt; Iterable&lt;Item&lt;'a&gt; = &amp;'a T&gt;,
) -&gt; Vec&lt;T&gt;
where
    T: Clone
{
    let mut out = vec![];
    for elem in iterable.iter() {
        out.push(elem.clone());
    }
    out
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's look at this function more closely. The most interesting part is the type of the <code>iterable</code> parameter:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>iterable: &amp;impl for&lt;'a&gt; Iterable&lt;Item&lt;'a&gt; = &amp;'a T&gt;,
//              ^^^^^^^          ^^^^^^^^
<span class="boring">}
</span></code></pre></pre>
<p>This admittedly verbose syntax is a way of saying:</p>
<ul>
<li><code>iterable</code> is some kind of <code>Iterable</code> that, when iterated with some lifetime <code>'a</code>, yields up values of type <code>&amp;'a T</code>.</li>
</ul>
<p>The <code>for&lt;'a&gt;</code> binder is a way of making this bound apply for any lifetime, rather than talking about some specific lifetime.</p>
<h2 id="applying-gats-to-a-specific-lifetime"><a class="header" href="#applying-gats-to-a-specific-lifetime">Applying GATs to a specific lifetime</a></h2>
<p>The previous example showed an iterable applied to any lifetime. It is also possible to give bounds for some specific lifetime. This function, for example, takes an <code>iterable</code> with lifetime <code>'i</code> and yields up the first element:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn first&lt;'i, T&gt;(
    iterable: &amp;'i impl Iterable&lt;Item&lt;'i&gt; = &amp;'i T&gt;,
) -&gt; Option&lt;&amp;'i T&gt;
{
    iterable.iter().next()
}
<span class="boring">}
</span></code></pre></pre>
<p>The bound <code>impl Iterable&lt;Item&lt;'i&gt; = &amp;'i T&gt;</code> says &quot;when iterated with lifetime <code>'i</code>, the resulting reference is <code>&amp;'i T</code>&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="required-bounds"><a class="header" href="#required-bounds">Required bounds</a></h1>
<p><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /> <img src="https://img.shields.io/badge/note-seeking%20feedback-informational" alt="seeking-feedback" /> </p>
<blockquote>
<p><em>We are actively soliciting feedback on the design of this aspect of GATs. This section explains the current nightly behavior, but at the end there is note about the behavior we expect to adopt in the future.</em></p>
</blockquote>
<p>A common use for GATs is to represent the lifetime of data that is borrowed from a value of type <code>Self</code>, or some other parameter. Consider the <code>iter</code> method of the <code>Iterable</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    ...

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the argument <code>'a</code> that is given to <code>Self::Iterator</code> represents the lifetime of the <code>self</code> reference. However, by default, there is nothing in the definition of the <code>Iterator</code> associated type that links its lifetime argument and the <code>Self</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Warning: For reasons we are in the midst of explaining,
// this version of the trait will not compile.
trait Iterable {
    type Item&lt;'me&gt;;

    type Iterator&lt;'me&gt;: Iterator&lt;Item = Self::Item&lt;'me&gt;&gt;;

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>If you try to compile this trait, you will find that you get an error. To make it compile, you have to indicate the link between <code>'me</code> and <code>Self</code> by adding <code>where Self: 'me</code>. This <a href="https://doc.rust-lang.org/nightly/reference/trait-bounds.html?highlight=outlives#lifetime-bounds">outlives bound</a> indicates the GATs can only be used with a lifetime <code>'me</code> that could legally be used to borrow <code>Self</code>. This version compiles:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Item&lt;'me&gt;
    where
        Self: 'me;

    type Iterator&lt;'me&gt;: Iterator&lt;Item = Self::Item&lt;'me&gt;&gt;
    where
        Self: 'me;

    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="why-are-these-bounds-required"><a class="header" href="#why-are-these-bounds-required">Why are these bounds required?</a></h2>
<p>Without these bounds, users of the trait would almost certainly not be able to write the impls that they need to write. Consider an implementation of <code>Iterable</code> for <code>Vec&lt;T&gt;</code>, assuming that there are no <code>where Self: 'me</code> bounds on the GATs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterable for Vec&lt;T&gt; {
    type Item&lt;'me&gt; = &amp;'me T;
    type Iterator&lt;'me&gt; = std::vec::Iter&lt;'me, T&gt;;
    fn iter(&amp;self) -&gt; Self::Iterator&lt;'_&gt; { self.iter() }
}
<span class="boring">}
</span></code></pre></pre>
<p>The problem comes from the associated types. Consider the <code>type Item&lt;'me&gt; = &amp;'me T</code> declaration, for example: for the type <code>&amp;'me T</code> to be legal, we must know that <code>T: 'me</code>. Otherwise, nothing stops us from using <code>Self::Item&lt;'static&gt;</code> to construct a reference with a lietime <code>'static</code> that may outlive its referent <code>T</code>, and that can lead to unsoundness in the type system. In the case of the <code>iter</code> method, the fact that it takes a parameter <code>self</code> of type <code>&amp;'me Vec&lt;T&gt;</code> already implies that <code>T: 'me</code> (otherwise that parameter would have an invalid type). However, that doesn't apply to the GAT <code>Item</code>. This is why the associated types need a where clause:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterable for Vec&lt;T&gt; {
    type Item&lt;'me&gt; = &amp;'me T where Self: 'me;
    type Iterator&lt;'me&gt; = std::vec::Iter&lt;'me, T&gt; where Self: 'me;
    fn iter(&amp;self) -&gt; Self::Iterator&lt;'_&gt; { self.iter() }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, this impl is not legal unless the trait <em>also</em> has a <code>where Self: 'me</code> requirement. Otherwise, the impl has more where clauses than the trait, and that causes a problem for generic users that don't know which impl they are using.</p>
<h2 id="precise-rules"><a class="header" href="#precise-rules">Precise rules</a></h2>
<p>The precise rules that the compiler uses to decide when to issue an error are as follows:</p>
<ul>
<li>For every GAT <code>G</code> in a trait definition with generic parameters <code>X0...Xn</code> from the trait and <code>Xn..Xm</code> on the GAT... (e.g., <code>Item</code> or <code>Iterable</code>, in the case of <code>Iterable</code>, with generic parameters <code>[Self]</code> from the trait and <code>['me]</code> from the GAT)
<ul>
<li>If for every method in the trait... (e.g., <code>iter</code>, in the case of <code>Iterable</code>)
<ul>
<li>When the method signature (argument types, return type, where clauses) references <code>G</code> like <code>&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::G&lt;Pn..Pm&gt;</code> (e.g., <code>&lt;Self as Iterable&gt;::Iterator&lt;'a&gt;</code>, in the <code>iter</code> method, where <code>P0 = Self</code> and <code>P1</code> = <code>'a</code>)...
<ul>
<li>we can show that <code>Pi: Pj</code> for two parameters on the reference to <code>G</code> (e.g., <code>Self: 'a</code>, in our example)
<ul>
<li>then the GAT must have <code>Xi: Xj</code> in its where clause list in the trait (e.g., <code>Self: 'me</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="plan-going-forward-add-rules-by-default"><a class="header" href="#plan-going-forward-add-rules-by-default">Plan going forward: Add rules by default</a></h2>
<p>In the future, rather than reporting an error in cases like this, we expect to add these where clauses to the trait and impl by default. However, there is some possibility that this will rule out legal impls for which the where clause might not be necessary. This can happen if either (a) the lifetime, despite being linked to a type like <code>Self</code> in the methods, is not used to borrow content from <code>Self</code>; or (b) in all impls of this trait that could exist, the types being borrowed don't have references and are known to be <code>'static</code>.</p>
<h2 id="feedback-requested"><a class="header" href="#feedback-requested">Feedback requested!</a></h2>
<p>The current compiler adds the future defaults as a <strong>hard error</strong> precisely so that we can get the attention of early users and find out if these where clauses pose any kind of problem. If you are finding that you have a trait and impls that you believe would compile fine, but doesn't because of these where clauses, then we would like to hear from you! Please <a href="https://github.com/rust-lang/generic-associated-types-initiative/issues/new/choose">file an issue</a> on this repository, and use the &quot;Feedback on required bounds&quot; template.</p>
<h3 id="workaround"><a class="header" href="#workaround">Workaround</a></h3>
<p>If you find that this requirement is causing you a problem, there is a workaround. You can refactor your trait into two traits. For example, to write a version of <code>Iterable</code> that doesn't require <code>where Self: 'me</code>, you might do the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IterableTypes {
    type Item&lt;'me&gt;;
    type Iterator&lt;'me&gt;: Iterator&lt;Item = Self::Item&lt;'me&gt;&gt;;
}

trait Iterable: IterableTypes {
    fn iter&lt;'a&gt;(&amp;'a self) -&gt; Self::Iterator&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This is a bit heavy-handed, but there's a logic to it: the rules are geared around ensuring that the associated types and methods that appear together in a single trait will work well together. By separating the associated types from the function into distinct traits, you are effectively asserting that the associated types are meant to be used independently from the function and hence it doesn't necessarily make sense to have the where clauses derived from the method signature.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-directions"><a class="header" href="#future-directions">Future directions</a></h1>
<p>There are some points about GATs which we expect to change. Deciding on the best solution, however, requires more information about the way GATs are used in practice. Therefore, we encourage you to [file a new issue] sharing your experiences and giving feedback on these points.</p>
<p>[open issues]: [file an issue]: https://github.com/rust-lang/generic-associated-types-initiative/issues/new/choose</p>
<h2 id="proposal-a-supply-a-hrefexplainerrequired_boundshtmlrequired-boundsa-by-default"><a class="header" href="#proposal-a-supply-a-hrefexplainerrequired_boundshtmlrequired-boundsa-by-default">Proposal A: Supply <a href="explainer/./required_bounds.html">required bounds</a> by default</a></h2>
<p>The first planned change is to make the <a href="explainer/./required_bounds.html">required bounds</a> on associated types be supplied by default, rather than requiring that they be typed explicitly. We may or may not include some form of annotation to &quot;opt-out&quot; from this default. In short, the expectation is that -- in practice -- virtually all traits will want these where clauses, and there will be negligibly few cases that do not. We are therefore looking for examples where having to add the required bounds was a problem, and you were forced to <a href="explainer/./required_bounds.html#workaround">adopt the workaround</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-rfc"><a class="header" href="#-rfc">‚ú® RFC</a></h1>
<p><a href="https://github.com/rust-lang/rfcs/pull/1598">RFC #1598</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-discussions"><a class="header" href="#design-discussions">Design discussions</a></h1>
<p>This directory hosts notes on important design discussions along with their resolutions.
In the table of contents, you will find the overall status:</p>
<ul>
<li>‚úÖ -- <strong>Settled!</strong> Input only needed if you have identified a fresh consideration that is not covered by the write-up.</li>
<li>üí¨ -- <strong>Under active discussion.</strong> Check the write-up, which may contain a list of questions or places where feedback is desired.</li>
<li>üí§ -- <strong>Paused.</strong> Not under active discussion, but we may be updating the write-up from time to time with details.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="outlives-defaults"><a class="header" href="#outlives-defaults">Outlives defaults</a></h1>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li>Discussion issue: <a href="https://github.com/rust-lang/rust/issues/87479">#87479</a></li>
</ul>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>We are moving towards stabilizing GATs (tracking issue: <a href="https://github.com/rust-lang/rust/issues/44265">#44265</a>) but there is one major ergonomic hurdle that we should decide how to manage before we go forward. In particular, a great many GAT use cases require a surprising where clause to be well-typed; this typically has the form <code>where Self: 'a</code>. In &quot;English&quot;, this states that the GAT can only be used with some lifetime <code>'a</code> that could've been used to borrow the <code>Self</code> type. This is because GATs are frequently used to return data owned by the <code>Self</code> type. It might be useful if we were to create some rules to add this rule by default. Once we stabilize, changing defaults will be more difficult, and could require an edition, therefore it's better to evaluate the rules now.</p>
<h2 id="i-have-an-opinion-what-should-i-do"><a class="header" href="#i-have-an-opinion-what-should-i-do">I have an opinion! What should I do?</a></h2>
<p>To make this decision in an informed way, <strong>what we need most are real-world examples and experience reports</strong>. If you are experimenting with GATs, for example, how often do you use <code>where Self: 'a</code> and how did you find out that it is necessary? Would the default proposals described below work for you? If not, can you describe the trait so we can understand why they would not work?</p>
<p>Of great use would be example usages that do NOT require <code>where Self: 'a</code>. It'd be good to be able to evaluate the various defaulting schemes and see whether they would interfere with the trait. Knowing the trait and a rough sketch of the impls would be helpful.</p>
<h2 id="background-what-where-clause-now"><a class="header" href="#background-what-where-clause-now">Background: what where clause now?</a></h2>
<p>Consider the typical &quot;lending iterator&quot; example. The idea here is to have an iterator that produces values that may have references into the <strong>iterator itself</strong> (as opposed to references into the collection being iterated over). In other words, given a <code>next</code> method like <code>fn next&lt;'a&gt;(&amp;'a mut self)</code>, the returned items have to be able to reference <code>'a</code>. The typical <code>Iterator</code> trait cannot express that, but GATs can:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'a&gt;;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, this trait definition turns out to be not quite right in practice. Consider an example like this, an iterator that yields a reference to the same item over and over again (note that it owns the item it is referencing):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefOnce&lt;T&gt; {
    my_data: T    
}

impl&lt;T&gt; LendingIterator for RefOnce&lt;T&gt; {
    type Item&lt;'a&gt; where Self: 'a = &amp;'a T;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt; {
        &amp;self.my_data
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the type <code>type Item&lt;'a&gt; = &amp;'a T</code> declaration is actually illegal. Why is that? The assumption when authoring the trait was that <code>'a</code> would always be the lifetime of the <code>self</code> reference in the <code>next</code> function, of course, but that is not in fact <em>required</em>. People can reference <code>Item</code> with any lifetime they want. For example, what if somebody wrote the type <code>&lt;SomeType&lt;T&gt; as LendingIterator&gt;::Item&lt;'static&gt;</code>? In this case, <code>T: 'static</code> would have to be true, but <code>T</code> may in fact contain borrowed references. This is why the compiler gives you a &quot;T may not outlive <code>'a</code>&quot; error (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=821e30ee635326a22fc19cd940bbaf62">playground</a>). </p>
<p>We can encode the constraint that &quot;<code>'a</code> is meant to be the lifetime of the <code>self</code> reference&quot; by adding a <code>where Self: 'a</code> clause to the <code>type Item</code> declaration. This is saying &quot;you can only use a <code>'a</code> that could be a reference to <code>Self</code>&quot;. If you make this change, you'll find that the code compiles (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=87cb2430ee76ece77499d3c6605874df">playground</a>): </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'a&gt; where Self: 'a;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="when-would-you-not-want-the-where-clause-self-a"><a class="header" href="#when-would-you-not-want-the-where-clause-self-a">When would you NOT want the where clause <code>Self: 'a</code>?</a></h2>
<p>If the associated type cannot refer to data that comes from the <code>Self</code> type, then the <code>where Self: 'a</code> is unnecessary, and is in fact somewhat constraining.</p>
<h3 id="example-output-doesnt-borrow-from-self"><a class="header" href="#example-output-doesnt-borrow-from-self">Example: Output doesn't borrow from Self</a></h3>
<p>In the <code>Parser</code> trait, the <code>Output</code> does not ultimately contain data borrowed from <code>self</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser {
    type Output&lt;'a&gt;;
    fn parse&lt;'a&gt;(&amp;mut self, data: &amp;'a [u8]) -&gt; Self::Output&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>If you were to implement <code>Parser</code> for some reference type (in this case, <code>&amp;'b Dummy</code>) you can now set <code>Output</code> to something that has no relation to <code>'b</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'b&gt; Parser for &amp;'b Dummy {
    type Output&lt;'a&gt; = &amp;'a [u8];

    fn parse&lt;'a&gt;(&amp;mut self, data: &amp;'a [u8]) -&gt; Self::Output&lt;'a&gt; {
        data 
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that you would need a similar <code>where</code> clause if you were going to have a setup like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Transform&lt;Input&gt; {
    type Output&lt;'a&gt;
    where
        Input: 'i;

    fn transform&lt;'i&gt;(&amp;mut self: &amp;'i Input) -&gt; Self::Output&lt;'i&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="example-iter-static"><a class="header" href="#example-iter-static">Example: Iter static</a></h3>
<p>In the previous example, the lifetime parameter for <code>Output</code> was not related to the <code>self</code> parameter. Are there (realistic) examples where the associated type is applied to the lifetime parameter from <code>self</code> <em>but</em> the <code>where Self: 'a</code> is not desired?</p>
<p>There are some, but they rely on having &quot;special knowledge&quot; of the types that will be used in the impl, and they don't seem especially realistic. The reason is that, if you have a GAT with a lifetime parameter, it is likely that the GAT contains some data borrowed for that lifetime! But if you use the lifetime of <code>self</code>, that implies we are borrowing some data from <code>self</code> -- however, it doesn't <em>necessarily</em> imply that we are borrowing data of any particular type. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Message {
    type Data&lt;'a&gt;: Display;

    fn data&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Data&lt;'b&gt;;

    fn default() -&gt; Self::Data&lt;'static&gt;;
}

struct MyMessage&lt;T&gt; {
    text: String,
    payload: T,
}

impl&lt;T&gt; Message for MyMessage&lt;T&gt; {
    type Data&lt;'a&gt;: Display = &amp;'a str;
    // No requirement that `T: 'a`!

    fn data&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Data&lt;'b&gt; {
        // In here, we know that `T: 'b`
    }

    fn default() -&gt; Self::Data&lt;'static&gt; {
        &quot;Hello, world&quot;        
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>where T: 'a</code> requirement is not necessary, and may in fact be annoying when invoking <code>&lt;MyMessage&lt;T&gt; as Message&gt;::default()</code> (as it would then require that <code>T: 'static</code>).</p>
<p>Another possibility is that the usage of <code>&lt;MyMessage&lt;T&gt; as Message&gt;::Data&lt;'static&gt;</code> doesn't appear inside the trait definition, although it is hard to imagine exactly how one writes a useful function like that in practice.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="status-quo"><a class="header" href="#status-quo">Status quo</a></h3>
<p>We ship with no default. This kind of locks in a box, because adding a default later would be a breaking change to existing impls that are affected by the default. since some of them may be using the associated types with a lifetime unrelated to <code>Self</code>. Note though that a sufficiently tailored default would only break code that was going to -- or perhaps <em>very likely to</em> -- not compile anyhow.</p>
<h3 id="smart-default-add-where-self-a-if-the-gat-is-used-with-the-lifetime-from-self-and-extend-to-other-type-parameters"><a class="header" href="#smart-default-add-where-self-a-if-the-gat-is-used-with-the-lifetime-from-self-and-extend-to-other-type-parameters">Smart default: add <code>where Self: 'a</code> if the GAT is used with the lifetime from <code>&amp;self</code> (and extend to other type parameters)</a></h3>
<p>Analyze the types of methods within the trait definition. It a GAT is applied to a lifetime <code>'x</code>, examine the implied bounds of the method for bounds of the form <code>T: 'x</code>, where <code>T</code> is an input parameter to the trait. If we find such bounds on all methods for every use of the GAT, then add the corresponding default.</p>
<p>Consider the <code>LendingIterator</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'a&gt;;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Analyzing the closure body, we see that it contains <code>Self::Item&lt;'b&gt;</code> where <code>'b</code> is the lifetime of the <code>self</code> reference (e.g., <code>self: &amp;'b Self</code> or <code>self: &amp;'b mut Self</code>). The implied bounds of this method contain <code>Self: 'b</code>. Since there is only one use of <code>Self::Item&lt;'b&gt;</code>, and the implied bound <code>Self: 'b</code> applies in that case, then we add the default <code>where Self: 'a</code> to the GAT. </p>
<p>This check is a fairly simple syntactic check, though not necessarily easy to explain. It would accept all the examples that appear in this document, including the example with <code>fn default() -&gt; Self::Data&lt;'static&gt;</code> (in that case, the default is not triggered, because we found a use of <code>Data</code> that is applied to a lifetime for which no implied bound applies). The only case where this default behaves <em>incorrectly</em> is the case where all uses of <code>Self::Data</code> that appear within the trait need the default, but there are uses outside the trait that do not (I couldn't come up with a realistic example of how to do this usefully).</p>
<h4 id="extending-to-other-type-parameters"><a class="header" href="#extending-to-other-type-parameters">Extending to other type parameters</a></h4>
<p>The inference can be extended naturally beyond <code>self</code> to other type parameters. Therefore this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser&lt;Input&gt; {
    type Output&lt;'i&gt;;

    fn get&lt;'input&gt;(&amp;mut self, i: &amp;'input Input) -&gt; Self::Output&lt;'input&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>would infer a <code>where Input: 'i</code> bound on <code>type Output&lt;'i&gt;</code>.</p>
<p>Similarly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser&lt;Input&gt; {
    type Output&lt;'i&gt;;

    fn get(&amp;mut self, i: &amp;'input Input) -&gt; Self::Output&lt;'input&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>would infer a <code>where Input: 'i</code> bound on <code>type Output&lt;'i&gt;</code>.</p>
<h4 id="avoiding-the-default"><a class="header" href="#avoiding-the-default">Avoiding the default</a></h4>
<p>If this default is truly not desired, there is a workaround: one can declare a supertrait that contains just the associated type. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IterType {
    type Iter&lt;'b&gt;;
}

trait LendingIterator: IterType {
    fn next(&amp;mut self) -&gt; Self::Iter&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This workaround is not especially obvious, however.</p>
<h4 id="related-precedent"><a class="header" href="#related-precedent">Related precedent</a></h4>
<p>We used to require <code>T: 'a</code> bounds in structs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T&gt; {
    x: &amp;'a T
}
<span class="boring">}
</span></code></pre></pre>
<p>but as of <a href="https://rust-lang.github.io/rfcs/2093-infer-outlives.html">RFC 2093</a> we infer such bounds from the fields in the struct body. In this case, if we do come up with a default rule, we are essentially inferring the presence of such bounds by usages of the associated type within the trait definition.</p>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Niko's recommendation is to use the &quot;smart defaults&quot;. Why? They basically always do the right thing, thus contributing to <a href="https://rustacean-principles.netlify.app/how_rust_empowers/supportive.html">supportive</a>, at the cost of (theoretical) <a href="https://rustacean-principles.netlify.app/how_rust_empowers/versatile.html">versatility</a>. This seems like the right trade-off to me.</p>
<p>The counterargument would be: the rules are sufficiently complex, we can potentially add this later, and people are going to be surprised by this default when it &quot;goes wrong&quot; for them. It would be hard, but not impossible, to add a tailored error message for cases where the <code>where T: 'b</code> check fails.</p>
<p>Not sure about Jack's opinion. =)</p>
<h2 id="appendix-a-ruled-out-alternatives"><a class="header" href="#appendix-a-ruled-out-alternatives">Appendix A: Ruled out alternatives</a></h2>
<h3 id="special-syntax"><a class="header" href="#special-syntax">Special syntax</a></h3>
<p>We could use the <code>'self</code> &quot;keyword&quot;, permitted only in GATs, to indicate &quot;a lifetime with the where clause <code>where Self: 'self</code>&quot;. The <code>LendingIterator</code> trait would therefore be written</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'self&gt;;

    fn next(&amp;mut self) -&gt; Self::Item&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Forwards compatibility note:</em> This option could be added later; note also that <code>'self</code> is not currently valid.</p>
<p><strong>Why not?</strong> <code>'self</code> is an awfully suggestive syntax. It may be useful for things like self-referential structs. This just doesn't important enough.</p>
<h3 id="force-people-to-write-where-self-a"><a class="header" href="#force-people-to-write-where-self-a">Force people to write <code>where Self: 'a</code></a></h3>
<p>To buy time, we could force people to write <code>where Self: 'a</code>, so that we can later allow it to be elided. This unfortunately would eliminate a number of valid use cases for GATs (though they would later be supported).</p>
<p><strong>Why not?</strong> Rules out a number of useful cases.</p>
<h3 id="dumb-default-always-default-to-where-self-a"><a class="header" href="#dumb-default-always-default-to-where-self-a">Dumb default: Always default to <code>where Self: 'a</code></a></h3>
<p>The most obvious default is to add <code>where Self: 'a</code> to the where clause list for any GAT with a lifetime parameter <code>'a</code>, but that seems too crude. It will rule out all existing cases unless we add some form of &quot;opt-out&quot; syntax, for which we have no real precedent.</p>
<p><strong>Why not?</strong> Rules out a number of useful cases.</p>
<h2 id="appendix-b-considerations"><a class="header" href="#appendix-b-considerations">Appendix B: Considerations</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/87479#issuecomment-890111937">How 'obvious' are the rules?</a></li>
</ul>
<h2 id="appendix-c-other-examples"><a class="header" href="#appendix-c-other-examples">Appendix C: Other examples</a></h2>
<h3 id="example-ruma"><a class="header" href="#example-ruma">Example: Ruma</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Every endpoint in the Matrix REST API has two request and response types in Ruma, one Incoming
// (used for deserialization) and out Outgoing (used for serialization). To avoid annoying clones when
// sending a request, most non-copy fields in the outgoing structs are references.
//
// The request traits have an associated type for the corresponding response type so things can be
// matched up properly.
pub trait IncomingRequest: Sized {
    // This is the current definition of the associated type I'd like to make generic.
    type OutgoingResponse: OutgoingResponse;
    // AFAICT adding a lifetime parameter is all I need.
    type OutgoingResponse&lt;'a&gt;: OutgoingResponse;

    // Other trait members... (not using Self::OutgoingResponse)
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/ruma-api/0.17.1/ruma_api/trait.IncomingRequest.html">full definition</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-where-does-the-where-clause-go"><a class="header" href="#-where-does-the-where-clause-go">üí¨ Where does the where clause go?</a></h1>
<p>This is write-up of the conclusion to the [where does the where clause go?] question. To read more background, see the <a href="design-discussions/where-the-where-1.html#links-to-older-discussions">links</a> section below.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<h3 id="where-clauses-in-generic-associated-types-comes-after-valuebinding"><a class="header" href="#where-clauses-in-generic-associated-types-comes-after-valuebinding">Where clauses in generic associated types comes after value/binding</a></h3>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    type MyType&lt;T&gt;: Iterator
    where
        T: Ord;
}
    
impl MyTrait for MyOtherType {
    type MyType&lt;T&gt; = MyIterator
    where
        T: Ord;
}
<span class="boring">}
</span></code></pre></pre>
<p>Effectively the <code>= type</code> in the impl replaces the <code>: Bound</code> from the declaration with the value that has to meet those bounds.</p>
<h3 id="later-phase-type-aliases"><a class="header" href="#later-phase-type-aliases">Later phase: type aliases</a></h3>
<p>Type aliases will eventually be aligned to this syntax as well:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type MyType&lt;T&gt; = Vec&lt;T&gt; where T: Ord;
<span class="boring">}
</span></code></pre></pre>
<p>Currently, however, where clauses on type aliases are ignored, so we will not stabilize this new syntax until they have the meaning we want.</p>
<h3 id="suggestions-for-users-who-put-the-where-clause-in-the-wrong-place"><a class="header" href="#suggestions-for-users-who-put-the-where-clause-in-the-wrong-place">Suggestions for users who put the where clause in the wrong place</a></h3>
<p>We will parse where clauses in both positions and suggest to users that they be moved:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyTrait for MyOtherType {
    type MyType&lt;T&gt;
    where
        T: Ord
    = MyIterator;
}
<span class="boring">}
</span></code></pre></pre>
<p>Gets an error with a suggested rewrite. The compiler proceeds &quot;as if&quot; the where clauses had been written after the <code>= Type</code>.</p>
<h3 id="where-clause-syntax-for-trait-aliases-will-have-to-be-revisited"><a class="header" href="#where-clause-syntax-for-trait-aliases-will-have-to-be-revisited">Where clause syntax for trait aliases will have to be revisited</a></h3>
<p>As described in the FAQ below, we currently support trait alias syntax like</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ReverseEq&lt;T&gt; = where T: PartialEq&lt;Self&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>This syntax will be removed. Although its capabilities could be useful, it is also quite confusing (the placement of the <code>where</code> is a subtle distinction), and not clearly needed. If we find that we do want it, we can add in a similar syntax later, but hopefully in a way that is more broadly consistent with the language.</p>
<h2 id="discussion-and-faq"><a class="header" href="#discussion-and-faq">Discussion and FAQ</a></h2>
<h3 id="but-isnt-it-inconsistent-with-other-trait-items-to-put-the-where-clauses-before-the-"><a class="header" href="#but-isnt-it-inconsistent-with-other-trait-items-to-put-the-where-clauses-before-the-">But isn't it inconsistent with other trait items to put the where clauses <em>before</em> the <code>=</code>?</a></h3>
<p>From one perspective, yes. One can view the value of an associated type as its &quot;body&quot;, and the where clauses typically come before the &quot;body&quot; of an item. Put another way, typically you can &quot;copy and paste&quot; the impl and then add some text to the end of each item to specify its value: but with this syntax, you have to edit the &quot;middle&quot; of an associated type to specify its value.</p>
<p>The analogy of an associated type value to a function body, however, is somewhat flawed. The value of an associated type needs to be considered part of the &quot;signature&quot;, or public facing, part of the impl. Consider: you can change the body of a function and be certain that your callees will still compile, but you cannot do the same for the value of an associated type.</p>
<p>Given this perspective, when you copy the associated type from the trait to the impl, you are &quot;completing&quot; the signature that was left incomplete by the trait. Moreover, to do so, you replace the <code>: Bound1 + Bound2</code> list (which constraints what kinds of types the impl might use) with a specific type, thus making it more specific.</p>
<h3 id="what-about-a-more-purely-syntactic-point-of-view-what-is-more-consistent"><a class="header" href="#what-about-a-more-purely-syntactic-point-of-view-what-is-more-consistent">What about a more purely syntactic point-of-view? What is more consistent?</a></h3>
<p>There is precedent that the placement of the where clause has less to do with the logical role that it plays and more to do with other factors, like whether it is followed by a braced list of items:</p>
<ul>
<li>With <code>struct Foo&lt;T&gt; where T: Ord { t: T }</code>, the &quot;body&quot; of the struct is its fields, and the where clause comes first.</li>
<li>But we write <code>struct Foo&lt;T&gt;(T) where T: Ord</code>, thus placing the &quot;body&quot; (the fields <code>(T)</code>) first and the where clause second. Moreover, we initially implemented the grammar <code>struct Foo&lt;T&gt; where T: Ord (T)</code> but this was deemed so obviously confusing that it was <a href="https://github.com/rust-lang/rust/issues/17904#issuecomment-58603749">changed with little discussion</a>.</li>
</ul>
<p>As further evidence that this syntax is inconsistent with Rust's traditions, placing the where clauses before the <code>= ty</code> makes it objectively hard to determine how to run rustfmt in a way that feels natural. rustfmt handles <code>where</code> by putting the <code>where</code> onto its own line, with one line per where clause. This structure works for existing Rust items because where clauses are always either following by nothing (tuple structs) or by a braced (<code>{}</code>) list of items (e.g., struct fields, fn body, etc). That opening <code>{</code> can therefore go on its own line. This <code>where</code> clause formatting does not work well with <code>=</code>.</p>
<p>The idea of having where clauses come at the &quot;end&quot; of the signature is also supported by the <a href="https://rust-lang.github.io/rfcs/0135-where.html#readability">original RFC</a>, which motivated where clauses in part by describing how they allow you to treat the precise bounds as &quot;secondary&quot; to the &quot;important stuff&quot;:</p>
<blockquote>
<p>If I may step aside from the &quot;impersonal voice&quot; of the RFC for a moment, I personally find that when writing generic code it is helpful to focus on the types and signatures, and come to the bounds later. Where clauses help to separate these distinctions. Naturally, your mileage may vary. - nmatsakis</p>
</blockquote>
<p>In the case of an impl specifying the value for an associated type, the &quot;important stuff&quot; the value of the associated type.</p>
<h3 id="what-about-trait-aliases-dont-they-distinguish-where-clause-placement"><a class="header" href="#what-about-trait-aliases-dont-they-distinguish-where-clause-placement">What about trait aliases, don't they distinguish where clause placement?</a></h3>
<p>As currently implemented, trait aliases have two distinct possible placements for where clauses, which effectively distinguishes between a <em>where clause</em> (which must be proven true in order to use the alias) and an <em>implied bound</em> (which is part of what the alias expands to). One can write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;T: Debug&gt; = Bar&lt;T&gt; + Baz&lt;T&gt;
<span class="boring">}
</span></code></pre></pre>
<p>in which case <code>where X: Foo&lt;Y&gt;</code> is only legal if <code>Y: Debug</code> is known from some other place. This is roughly equivalent to a trait like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo1&lt;T: Debug&gt;: Bar&lt;T&gt; + Baz&lt;T&gt; { }
<span class="boring">}
</span></code></pre></pre>
<p>The clause <code>where X: Foo1&lt;Y&gt;</code> is also only valid when <code>Y: Debug</code> is known. This is in contrast to the &quot;supertraits&quot; <code>Bar&lt;Y&gt;</code> and <code>Baz&lt;Y&gt;</code>, which are implied by <code>X: Foo1&lt;Y&gt;</code> (&quot;supertraits&quot; are also sometimes called &quot;implied bounds&quot;).</p>
<p>Alternatively, one can include the where clause in the &quot;value&quot; of the trait alias like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ReverseEq&lt;T&gt; = where T: PartialEq&lt;Self&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>In this case, <code>where X: ReverseEq&lt;Y&gt;</code> is equivalent to <code>Y: PartialEq&lt;X&gt;</code>. There is no &quot;equivalent trait&quot; for usage like this; the <code>T: PartialEq&lt;Self&gt;</code> effectively acts like a supertrait or implied bound.</p>
<p>Our decision was that this is a subtle distinction and that using the placement of the where clause was not a great way to make it.</p>
<h3 id="is-that-trait-alias-syntax-consistent-with-the-rest-of-the-language"><a class="header" href="#is-that-trait-alias-syntax-consistent-with-the-rest-of-the-language">Is that trait alias syntax consistent with the rest of the language?</a></h3>
<p>Not really. There are other places in the language that could benefit from a similar flexibility around implied bounds. For example, one could imagine wanting to have an associated type <code>T::MyType&lt;Y&gt;</code> where it is known that <code>Y: PartialEq&lt;T::MyType&lt;Y&gt;&gt;</code>, but this cannot be readily written with today's syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait MyTrait {
    type MyType&lt;T&gt;: PartialEq&lt;T&gt;;
    //              ^^^^^^^^^ not what we wanted
}
<span class="boring">}
</span></code></pre></pre>
<p>We decided that if we were going to offer that capability, we should find a way to offer it more generally, and hopefully with more clarity than putting the where clause before or after the <code>=</code>. As we have seen, where clauses for different kinds of items can be rather variable in their placement, so it is not clear that all users will recognize that distinction and understand it (many present in the meeting were surprised by the distinction as well).</p>
<p>Alternatively, the implied bounds proposal goes another way, turning most where clauses into implied bounds by default!</p>
<h3 id="why-do-you-even-need-where-clauses-in-the-impl-anyway"><a class="header" href="#why-do-you-even-need-where-clauses-in-the-impl-anyway">Why do you even need where clauses in the impl anyway?</a></h3>
<p>Given that the where clauses appear in the trait, you might wonder why they are needed in the impl anyway. After all, the impl could just assume that the trait bounds are met when checking the value of the associated type for validity, making the whole issue moot.</p>
<p>This would however be inconsistent with other sorts of items, which do require users to copy over the bounds from the trait. Furthermore, we have discussed the idea of allowing impls to relax the bounds from those described in the trait if they are not needed in the impl -- this came up most recently in the context of allowing impls to forego the <code>unsafe</code> keyword for <code>unsafe fn</code> declared in the trait if the fn in the impl body is completely safe. This could then even be relied upon by people invoking the method who know the precise impl they will be using.</p>
<p>In short, this might be a reasonable choice to make, but we should make it uniformly, and it shuts down the direction of using the lack of bounds in the impl as a kind of signal.</p>
<h3 id="why-not-change-type-alias-notation-too"><a class="header" href="#why-not-change-type-alias-notation-too">Why not change type alias notation too?</a></h3>
<p>Top-level type aliases currently parse with the where clause before the <code>=</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;T&gt; where T: Ord = T;
<span class="boring">}
</span></code></pre></pre>
<p>If you try that above example, however, you will find that you get a warning: this is because the <code>where T: Ord</code> is completely ignored! This is an implementation limitation in the way the current compiler eagerly expands type aliases. Moving the placement of where clauses actually gives us an opportunity to change this behavior without breaking any existing code, which is nice. It will however require some kind of opt-in (such as a <code>cargo fix</code> run) to migrate existing code that uses where clauses in the &quot;ignored place&quot; to the new format.</p>
<h2 id="links-to-older-discussions"><a class="header" href="#links-to-older-discussions">Links to older discussions</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/90076">Implementation PR</a></li>
<li><a href="https://rust-lang.github.io/generic-associated-types-initiative/design-discussions/where-the-where.html">Design document</a></li>
<li><a href="https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-10-13-where-the-where.md">Design meeting minutes</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/89122">Rust issue</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="where-does-the-where-clause-go"><a class="header" href="#where-does-the-where-clause-go">Where does the where clause go?</a></h1>
<h2 id="update"><a class="header" href="#update">UPDATE</a></h2>
<p>This document is retained for historical purposes. See the <a href="design-discussions/./where-the-where-1.html">Where the Where</a> conclusion for the most up-to-date conversation.</p>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>Proposed: to alter the syntax of where clauses on type aliases so that they appear <em>after</em> the value:</p>
<pre><code>type StringMap&lt;K&gt; = BTreeMap&lt;K, String&gt;
where
    K: PartialOrd
</code></pre>
<p>This applies both in top-level modules and in trats (associated types, generic or otherwise).</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The current syntax for where to place the &quot;where clause&quot; of a generic associated types is awkward. Consider this example (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bdb55a5d5cb17e20d73e22a3f2db0e57">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Iter&lt;'a&gt; where Self: 'a;

    fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt;;
}

impl&lt;T&gt; Iterable for Vec&lt;T&gt; {
    type Iter&lt;'a&gt;
    where 
        Self: 'a = &lt;&amp;'a [T] as IntoIterator&gt;::IntoIter;

    fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
        self.iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note the impl. Most people expect the impl to be written as follows (indeed, the author wrote it this way in the first draft):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Iterable for Vec&lt;T&gt; {
    type Iter&lt;'a&gt;  = &lt;&amp;'a [T] as Iterator&gt;::Iter
    where 
        Self: 'a;

    fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
        self.iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>However, this placement of the where clause is in fact rather inconsistent, since the <code>= &lt;&amp;'a [T] as Iterator&gt;::Iter</code> is in some sense the &quot;body&quot; of the item.</p>
<p>The same current syntax is used for where clauses on type aliases (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=74eeed1795b693f238150f825a0e8438">playground</a>):</p>
<pre><pre class="playground"><code class="language-rust">type Foo&lt;T&gt; where T: Eq = Vec&lt;T&gt;;

fn main() { }
</code></pre></pre>
<h2 id="top-level-type-aliases"><a class="header" href="#top-level-type-aliases">Top-level type aliases</a></h2>
<p>Currently, we accept where clauses in top-level type aliases, but they are deprecated (warning) and semi-ignored:</p>
<pre><code>type StringMap&lt;K&gt; where
    K: PartialOrd
= BTreeMap&lt;K, String&gt;
</code></pre>
<p>Under this proposal, this syntax remains, but is deprecated. The newer syntax for type aliases (with <code>where</code> coming after the type) would remain feature gated until such time as we enforce the expected semantics.</p>
<h2 id="alternatives-1"><a class="header" href="#alternatives-1">Alternatives</a></h2>
<h3 id="keep-the-current-syntax"><a class="header" href="#keep-the-current-syntax">Keep the current syntax.</a></h3>
<p>In this case, we must settle the question of how we expect it to be formatted (surely not as I have shown it above).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterable for Vec&lt;T&gt; {
    type Iter&lt;'a&gt; where Self: 'a 
        = &lt;&amp;'a [T] as IntoIterator&gt;::IntoIter;

    fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
        self.iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="accept-either"><a class="header" href="#accept-either">Accept either</a></h3>
<p>What do we do if both are supplied?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="-faq"><a class="header" href="#-faq">üòï FAQ</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
