<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>💬 Outlives defaults - Generic Associated Types Initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">👋 Welcome</a></li><li class="chapter-item "><a href="../CHARTER.html">📜 Charter</a></li><li class="chapter-item "><a href="../mvp.html">🏗️ MVP Stabilization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../mvp/concern-too-complex.html">Concern: GATs permit abstractions that make Rust harder to use</a></li><li class="chapter-item "><a href="../mvp/concern-too-rough.html">Concern: GATs are too hard to learn, especially in their current state</a></li><li class="chapter-item "><a href="../mvp/concern-lifetimes-only.html">Concern: we should stabilize lifetime GATs only</a></li><li class="chapter-item "><a href="../mvp/concern-backcompat.html">Concern: not confident the current MVP is backwards compatible</a></li><li class="chapter-item "><a href="../mvp/concern-right-rules-for-required-bounds.html">Concern: Do we have the right rules for required bounds?</a></li></ol></li><li class="chapter-item "><a href="../explainer.html">📚 Explainer</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/motivation.html">Why GATs?</a></li><li class="chapter-item "><a href="../explainer/iterable.html">Defining and implementing the Iterable trait with GATs</a></li><li class="chapter-item "><a href="../explainer/where-clauses.html">GATs in where-clauses</a></li><li class="chapter-item "><a href="../explainer/rough_edges.html">Rough edges</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/required_bounds.html">Required bounds</a></li><li class="chapter-item "><a href="../explainer/no_implied_bounds.html">No implied bounds on HRTB</a></li></ol></li></ol></li><li class="chapter-item "><a href="../shiny_future.html">🔮 Shiny future</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../shiny_future/iterable.html">Defining and implementing the Iterable trait with GATs</a></li><li class="chapter-item "><a href="../shiny_future/where-clauses.html">GATs in where-clauses</a></li><li class="chapter-item "><a href="../shiny_future/proposals.html">Proposals</a></li></ol></li><li class="chapter-item "><a href="../design_patterns.html">✍️ Design patterns</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../design_patterns/iterable.html">Iterable and lending iterators</a></li><li class="chapter-item "><a href="../design_patterns/many_modes.html">Many modes</a></li><li class="chapter-item "><a href="../design_patterns/generic_scopes.html">Generic scopes</a></li><li class="chapter-item "><a href="../design_patterns/pointer_types.html">Pointer types</a></li></ol></li><li class="chapter-item expanded "><a href="../design-discussions/index.html">💬 Design discussions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-discussions/outlives-defaults.html" class="active">💬 Outlives defaults</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../design-discussions/outlives-defaults-1.html">Initial write-up</a></li></ol></li><li class="chapter-item "><a href="../design-discussions/where-the-where-1.html">💬 Where does the where clause go?</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../design-discussions/where-the-where.html">Initial write-up</a></li></ol></li><li class="chapter-item "><a href="../design-discussions/complexity.html">💬 Are GATs too complex?</a></li><li class="chapter-item "><a href="../design-discussions/lifetimes-only.html">💬 Should GATs only support lifetime parameters?</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">😕 FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Generic Associated Types Initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/generic-associated-types-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="outlives-defaults"><a class="header" href="#outlives-defaults">Outlives defaults</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>GATs as naively implemented have a major footgun. Given a trait like this...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Iter&lt;'c&gt;;

    fn iter&lt;'s&gt;(&amp;'s self) -&gt; Self::Iter&lt;'s&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>...users would not be able to write a typical impl, e.g....</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Iterable for Vec&lt;T&gt; {
    type Iter&lt;'c&gt; = std::slice::Iter&lt;'c, T&gt;;

    fn iter(&amp;self) -&gt; Self::Iter&lt;'_&gt; {
        self.iter()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This would not work because the type <code>Iter&lt;'c, T&gt;</code> is only well-formed if <code>T: 'c</code>, and that is not known on the associated type. How should we manage this?</p>
<h2 id="conclusion-require-probably-needed-where-clauses-on-gats-to-be-written-explicitly"><a class="header" href="#conclusion-require-probably-needed-where-clauses-on-gats-to-be-written-explicitly">Conclusion: Require &quot;probably needed&quot; where-clauses on GATs to be written explicitly</a></h2>
<p>The original write-up and details of the discussion can be found <a href="./outlives-defaults-1.html">here</a>. The conclusion was to adopt the most conservative route and <strong>require</strong> users to explicitly write a set of where clauses on associated types. These where-clauses are deduced by examining the method signatures of methods that appear in the same trait, looking for relationships that hold within the methods and requiring those same relationships to be reproduced on the associated type.</p>
<p>In our example trait <code>Iterable</code>...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Iter&lt;'c&gt;;

    fn iter&lt;'s&gt;(&amp;'s self) -&gt; Self::Iter&lt;'s&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>...the method <code>iter</code> returns <code>&lt;Self as Iterable&gt;::Iter&lt;'s&gt;</code> (written in fully qualified form), and we have that <code>self: &amp;'s Self</code>. The parameter type implies that <code>Self: 's</code>, and therefore we require the bound <code>where Self: 'c</code> to be placed on the associated type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Iter&lt;'c&gt;
    where
        Self: 'c; // required for trait to compile

    fn iter&lt;'s&gt;(&amp;'s self) -&gt; Self::Iter&lt;'s&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<p>The rationale for this decision is that it is the most forwards compatible one: we can opt to remove the required bounds later, and all code still works. We can also opt to add the required bounds by default later, and all existing code still works, it is merely more explicit than required.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<p>You can read more about this decision here:</p>
<ul>
<li>The explainer has a <a href="../explainer/required_bounds.html">page on this decision</a> that gives a more thorough explanation and covers how you can give feedback if you are finding this infereres with a trait you are trying to write.</li>
<li>The <a href="./outlives-defaults-1.html">original write-up and associated discussion</a> is available. The issue was also discussed on <a href="https://github.com/rust-lang/rust/issues/87479">#87479</a> and there was also a <a href="https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2021-09-22-GAT-defaults.md">lang team design meeting</a>.</li>
<li>This page supplied a reference version of the semantics, works through some examples, and motivates the rules.</li>
</ul>
<h2 id="reference-rules"><a class="header" href="#reference-rules">Reference rules</a></h2>
<p>The precise rules are as follows:</p>
<ul>
<li>For every GAT <code>G</code> in a trait definition with generic parameters <code>X0...Xn</code> from the trait and <code>Xn..Xm</code> on the GAT... (e.g., <code>Item</code> or <code>Iterable</code>, in the case of <code>Iterable</code>, with generic parameters <code>[Self]</code> from the trait and <code>['me]</code> from the GAT)
<ul>
<li>If, for every method in the trait... (e.g., <code>iter</code>, in the case of <code>Iterable</code>)
<ul>
<li>When the method signature (argument types, return type, where clauses) references <code>G</code> like <code>&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::G&lt;Pn..Pm&gt;</code> (e.g., <code>&lt;Self as Iterable&gt;::Iterator&lt;'a&gt;</code>, in the <code>iter</code> method, where <code>P0 = Self</code> and <code>P1</code> = <code>'a</code>)...
<ul>
<li>we can show that <code>Pi: Pj</code> for two parameters on the reference to <code>G</code>, and <code>Pi</code> is not <code>'static</code> (e.g., <code>Self: 'a</code>, in our example)
<ul>
<li>then the GAT must have <code>Xi: Xj</code> in its where clause list in the trait (e.g., <code>Self: 'me</code>).</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h2>
<h3 id="can-you-work-through-the-iterable-example-in-more-detail"><a class="header" href="#can-you-work-through-the-iterable-example-in-more-detail">Can you work through the <code>Iterable</code> example in more detail?</a></h3>
<p>You mean the reference example from this page? Sure! This trait requires a <code>where Self: 'c</code> clause on the associated type <code>Iter</code>...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterable {
    type Iter&lt;'c&gt;;

    fn iter&lt;'s&gt;(&amp;'s self) -&gt; Self::Iter&lt;'s&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>...this occurs because:</p>
<ul>
<li>the <code>iter</code> function references <code>&lt;Self as Iterable&gt;::Iter&lt;'s&gt;</code> in its return type</li>
<li>we can show that <code>Self: 's</code> in the method environment</li>
<li>and <code>Self</code> is not <code>'static</code> (in fact, it's a type, not a lifetime)</li>
<li>when we translate <code>Self: 's</code> into the namespace of <code>Iter</code>, we wind up with <code>Self: 'c</code>, which is the required bound</li>
</ul>
<h3 id="why-do-the-rules-ignore-parameters-equal-to-static"><a class="header" href="#why-do-the-rules-ignore-parameters-equal-to-static">Why do the rules ignore parameters equal to <code>'static</code>?</a></h3>
<p>Consider <a href="https://github.com/rust-lang/rust/issues/87479#issuecomment-1010484170">this example</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![feature(generic_associated_types)]

<span class="boring">fn main() {
</span>trait X&lt;'a&gt; {
    type Y&lt;'b&gt;;
    fn foo(&amp;self) -&gt; Self::Y&lt;'static&gt;;
})):
<span class="boring">}
</span></code></pre></pre>
<p>Without the special case for <code>'static</code>, we would see that the return type includes</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Self as X&lt;'a&gt;&gt;::Y&lt;'static&gt;
<span class="boring">}
</span></code></pre></pre>
<p>and then check that <code>'static: 'a</code> (it does, unsurprisingly), and hence conclude that we need to preserve that relationship by adding a <code>where 'b: 'a</code> clause to the associated type. But that where clause isn't likely to help any impls type check. In fact, the fact that <code>Self::Y&lt;'static&gt;</code> can be hard-coded into the trait signature suggests that, for all impls, the value of <code>Y</code> must either (a) not reference <code>'b</code> or else (b) only use <code>'b</code> as part of some ref <code>&amp;'b T</code> where <code>T: 'static</code>. So really there isn't much point to adding where-clauses relating <code>'b</code>. You <em>could</em> imagine that an impl might want to have <code>&amp;'a &amp;'b u32</code>, and to rely on the fact that <code>'b: 'a</code> in every case where it appears in the interface -- but right now, the only usage in the interface is <code>'static</code>, and so that same type could just be <code>&amp;'a &amp;'static u32</code>, which would work fine.</p>
<h3 id="how-do-you-know-youve-gotten-the-exact-rules-for-required-bounds-correct-for-backcompat"><a class="header" href="#how-do-you-know-youve-gotten-the-exact-rules-for-required-bounds-correct-for-backcompat">How do you <em>know</em> you've gotten the exact rules for required bounds correct (for backcompat)?</a></h3>
<p>Well, we are pretty sure, because our algorithm is quite general. It essentially looks for any patterns or relationships between parameters found in the method signatures of the trait, modulo the carve-out for <code>'static</code> described in answer to the previous question. It's possible that we could find a source of relationships we haven't considered, or we could find that the carve-out masks something more common, but those seem unlikely, and regardless they would likely be quite obscure cases (and hence it may be possible to tweak the rules without affecting existing code, or tweak the rules in an edition).</p>
<h3 id="bounds-against-other-parameters"><a class="header" href="#bounds-against-other-parameters">Bounds against other parameters</a></h3>
<p>The required bounds sometimes relate to parameters on the trait itself, and not the GAT parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Get&lt;'a&gt; {
    type Item&lt;'c&gt;
    where
        Self: 'a; // &lt;-- Required

    fn get(&amp;'a self) -&gt; Self::Item&lt;'static&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>The reason for this is that the value of the <code>Item</code> type likely incorporates <code>'a</code> and <code>Self</code> and relies on the relationships of those types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Get&lt;'a&gt; {
    type Item&lt;'c&gt;
    where
        Self: 'a; // &lt;-- Required

    fn get(&amp;'a self) -&gt; Self::Item&lt;'static&gt;;
}

impl&lt;'a, 'b&gt; Get&lt;'a&gt; for &amp;'b [String] {
    type Item&lt;'c&gt; = &amp;'a str;

    fn get(&amp;'a self) -&gt; Self::Item&lt;'static&gt; {
        &amp;self[0]
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="why-not-issue-default-bounds-against-other-associated-types"><a class="header" href="#why-not-issue-default-bounds-against-other-associated-types">Why not issue default bounds against other associated types?</a></h3>
<p>Hmm, good question! It turns out that the idea of default bounds <em>is</em> applicable beyond GATs. For example, you might have a trait</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Iterator&lt;'i&gt; {
    type Item;

    fn foo(&amp;'i self) -&gt; Self::Item;
}
<span class="boring">}
</span></code></pre></pre>
<p>and the code could suggest that <code>type Item</code> wants a where-clause like <code>where Self: 'i</code>. After all, it will only be used in cases where <code>&amp;'i self</code> is valid type.</p>
<p>We actually tried to enable default bounds but found that it caused the compiler to fail to bootstrap. Interestingly the trait in question was found in gimli, and it turned out to be a case where the default bounds <em>weren't wrong</em>. They were expressing a lifetime relationship that the trait did require, but that relationship was being encoded on the trait in a different, arguably more roundabout way. The trait in question is the <a href="https://github.com/gimli-rs/object/blob/0a38064531fef4ddbaf93770a3551d333338980e/src/read/traits.rs#L24"><code>Object</code> trait</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An object file.
pub trait Object&lt;'data: 'file, 'file&gt;: read::private::Sealed {
    ...
    type SectionIterator: Iterator&lt;Item = Self::Section&gt;;
    ...
    fn sections(&amp;'file self) -&gt; Self::SectionIterator;
}
<span class="boring">}
</span></code></pre></pre>
<p>The error here suggested adding <code>where Self: 'file</code> to the <code>type SectionIterator</code>. Interestingly, if you look closely at the trait header, you can see that it is <code>'data: 'file</code>. This <code>'data</code> lifetime turns out to be the lifetime of data that appears in <code>Self</code>. So e.g. an <a href="https://github.com/gimli-rs/object/blob/0b76070f1281ebfad5b6b79c74f0c2508e5ee85c/src/read/coff/file.rs#L54">example impl</a> looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'data, 'file, R&gt; Object&lt;'data, 'file&gt; for CoffFile&lt;'data, R&gt;
where
    'data: 'file,
    R: 'file + ReadRef&lt;'data&gt;,
{
    type Segment = CoffSegment&lt;'data, 'file, R&gt;;
    type SegmentIterator = CoffSegmentIterator&lt;'data, 'file, R&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>In other words, the default bound of <code>where Self: 'file</code> was correct, but was being managed in a more complex way by the trait -- i.e., by adding a special lifetime (<code>'data</code>) into the trait signature that reflects &quot;the lifetime of borrowed data in <code>Self</code>&quot;, and then relating that lifetime to <code>'file</code>. In fact, the entire <code>Object</code> trait in gimil looks like it probably wanted to be a GAT, roughly like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// An object file.
pub trait Object: read::private::Sealed {
    ...
    type SectionIterator&lt;'file&gt;: Iterator&lt;Item = Self::Section&gt;
    where
        Self: 'file;
    ...
    fn sections(&amp;self) -&gt; Self::SectionIterator&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>To my eyes, this is unquestionably a simpler trait (and it fits what will likely become a fairly standard pattern).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../design-discussions/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../design-discussions/outlives-defaults-1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../design-discussions/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../design-discussions/outlives-defaults-1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
