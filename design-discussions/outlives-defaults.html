<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>üí¨ Outlives defaults - Generic Associated Types Initiative</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../explainer.html">üìö Explainer</a></li><li class="chapter-item "><a href="../RFC.html">‚ú® RFC</a></li><li class="chapter-item expanded "><a href="../design-discussions/index.html">üí¨ Design discussions</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../design-discussions/outlives-defaults.html" class="active">üí¨ Outlives defaults</a></li><li class="chapter-item "><a href="../design-discussions/where-the-where.html">üí¨ Where does the where clause go?</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Generic Associated Types Initiative</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        <a href="https://github.com/rust-lang/generic-associated-types-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                                                
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="outlives-defaults"><a class="header" href="#outlives-defaults">Outlives defaults</a></h1>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<ul>
<li>Discussion issue: <a href="https://github.com/rust-lang/rust/issues/87479">#87479</a></li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We are moving towards stabilizing GATs (tracking issue: <a href="https://github.com/rust-lang/rust/issues/44265">#44265</a>) but there is one major ergonomic hurdle that we should decide how to manage before we go forward. In particular, a great many GAT use cases require a surprising where clause to be well-typed; this typically has the form <code>where Self: 'a</code>. In &quot;English&quot;, this states that the GAT can only be used with some lifetime <code>'a</code> that could've been used to borrow the <code>Self</code> type. This is because GATs are frequently used to return data owned by the <code>Self</code> type. It might be useful if we were to create some rules to add this rule by default. Once we stabilize, changing defaults will be more difficult, and could require an edition, therefore it's better to evaluate the rules now.</p>
<h2 id="i-have-an-opinion-what-should-i-do"><a class="header" href="#i-have-an-opinion-what-should-i-do">I have an opinion! What should I do?</a></h2>
<p>To make this decision in an informed way, <strong>what we need most are real-world examples and experience reports</strong>. If you are experimenting with GATs, for example, how often do you use <code>where Self: 'a</code> and how did you find out that it is necessary? Would the default proposals described below work for you? If not, can you describe the trait so we can understand why they would not work?</p>
<p>Of great use would be example usages that do NOT require <code>where Self: 'a</code>. It'd be good to be able to evaluate the various defaulting schemes and see whether they would interfere with the trait. Knowing the trait and a rough sketch of the impls would be helpful.</p>
<h2 id="background-what-where-clause-now"><a class="header" href="#background-what-where-clause-now">Background: what where clause now?</a></h2>
<p>Consider the typical &quot;lending iterator&quot; example. The idea here is to have an iterator that produces values that may have references into the <strong>iterator itself</strong> (as opposed to references into the collection being iterated over). In other words, given a <code>next</code> method like <code>fn next&lt;'a&gt;(&amp;'a mut self)</code>, the returned items have to be able to reference <code>'a</code>. The typical <code>Iterator</code> trait cannot express that, but GATs can:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'a&gt;;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Unfortunately, this trait definition turns out to be not quite right in practice. Consider an example like this, an iterator that yields a reference to the same item over and over again (note that it owns the item it is referencing):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefOnce&lt;T&gt; {
    my_data: T    
}

impl&lt;T&gt; LendingIterator for RefOnce&lt;T&gt; {
    type Item&lt;'a&gt; where Self: 'a = &amp;'a T;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt; {
        &amp;self.my_data
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, the type <code>type Item&lt;'a&gt; = &amp;'a T</code> declaration is actually illegal. Why is that? The assumption when authoring the trait was that <code>'a</code> would always be the lifetime of the <code>self</code> reference in the <code>next</code> function, of course, but that is not in fact <em>required</em>. People can reference <code>Item</code> with any lifetime they want. For example, what if somebody wrote the type <code>&lt;SomeType&lt;T&gt; as LendingIterator&gt;::Item&lt;'static&gt;</code>? In this case, <code>T: 'static</code> would have to be true, but <code>T</code> may in fact contain borrowed references. This is why the compiler gives you a &quot;T may not outlive <code>'a</code>&quot; error (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=821e30ee635326a22fc19cd940bbaf62">playground</a>). </p>
<p>We can encode the constraint that &quot;<code>'a</code> is meant to be the lifetime of the <code>self</code> reference&quot; by adding a <code>where Self: 'a</code> clause to the <code>type Item</code> declaration. This is saying &quot;you can only use a <code>'a</code> that could be a reference to <code>Self</code>&quot;. If you make this change, you'll find that the code compiles (<a href="https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=87cb2430ee76ece77499d3c6605874df">playground</a>): </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'a&gt; where Self: 'a;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="when-would-you-not-want-the-where-clause-self-a"><a class="header" href="#when-would-you-not-want-the-where-clause-self-a">When would you NOT want the where clause <code>Self: 'a</code>?</a></h2>
<p>If the associated type cannot refer to data that comes from the <code>Self</code> type, then the <code>where Self: 'a</code> is unnecessary, and is in fact somewhat constraining.</p>
<h3 id="example-output-doesnt-borrow-from-self"><a class="header" href="#example-output-doesnt-borrow-from-self">Example: Output doesn't borrow from Self</a></h3>
<p>In the <code>Parser</code> trait, the <code>Output</code> does not ultimately contain data borrowed from <code>self</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser {
    type Output&lt;'a&gt;;
    fn parse&lt;'a&gt;(&amp;mut self, data: &amp;'a [u8]) -&gt; Self::Output&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>If you were to implement <code>Parser</code> for some reference type (in this case, <code>&amp;'b Dummy</code>) you can now set <code>Output</code> to something that has no relation to <code>'b</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'b&gt; Parser for &amp;'b Dummy {
    type Output&lt;'a&gt; = &amp;'a [u8];

    fn parse&lt;'a&gt;(&amp;mut self, data: &amp;'a [u8]) -&gt; Self::Output&lt;'a&gt; {
        data 
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that you would need a similar <code>where</code> clause if you were going to have a setup like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Transform&lt;Input&gt; {
    type Output&lt;'a&gt;
    where
        Input: 'i;

    fn transform&lt;'i&gt;(&amp;mut self: &amp;'i Input) -&gt; Self::Output&lt;'i&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="example-iter-static"><a class="header" href="#example-iter-static">Example: Iter static</a></h3>
<p>In the previous example, the lifetime parameter for <code>Output</code> was not related to the <code>self</code> parameter. Are there (realistic) examples where the associated type is applied to the lifetime parameter from <code>self</code> <em>but</em> the <code>where Self: 'a</code> is not desired?</p>
<p>There are some, but they rely on having &quot;special knowledge&quot; of the types that will be used in the impl, and they don't seem especially realistic. The reason is that, if you have a GAT with a lifetime parameter, it is likely that the GAT contains some data borrowed for that lifetime! But if you use the lifetime of <code>self</code>, that implies we are borrowing some data from <code>self</code> -- however, it doesn't <em>necessarily</em> imply that we are borrowing data of any particular type. Consider this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Message {
    type Data&lt;'a&gt;: Display;

    fn data&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Data&lt;'b&gt;;

    fn default() -&gt; Self::Data&lt;'static&gt;;
}

struct MyMessage&lt;T&gt; {
    text: String,
    payload: T,
}

impl&lt;T&gt; Message for MyMessage&lt;T&gt; {
    type Data&lt;'a&gt;: Display = &amp;'a str;
    // No requirement that `T: 'a`!

    fn data&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Data&lt;'b&gt; {
        // In here, we know that `T: 'b`
    }

    fn default() -&gt; Self::Data&lt;'static&gt; {
        &quot;Hello, world&quot;        
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the <code>where T: 'a</code> requirement is not necessary, and may in fact be annoying when invoking <code>&lt;MyMessage&lt;T&gt; as Message&gt;::default()</code> (as it would then require that <code>T: 'static</code>).</p>
<p>Another possibility is that the usage of <code>&lt;MyMessage&lt;T&gt; as Message&gt;::Data&lt;'static&gt;</code> doesn't appear inside the trait definition, although it is hard to imagine exactly how one writes a useful function like that in practice.</p>
<h2 id="alternatives"><a class="header" href="#alternatives">Alternatives</a></h2>
<h3 id="status-quo"><a class="header" href="#status-quo">Status quo</a></h3>
<p>We ship with no default. This kind of locks in a box, because adding a default later would be a breaking change to existing impls that are affected by the default. since some of them may be using the associated types with a lifetime unrelated to <code>Self</code>. Note though that a sufficiently tailored default would only break code that was going to -- or perhaps <em>very likely to</em> -- not compile anyhow.</p>
<h3 id="smart-default-add-where-self-a-if-the-gat-is-used-with-the-lifetime-from-self-and-extend-to-other-type-parameters"><a class="header" href="#smart-default-add-where-self-a-if-the-gat-is-used-with-the-lifetime-from-self-and-extend-to-other-type-parameters">Smart default: add <code>where Self: 'a</code> if the GAT is used with the lifetime from <code>&amp;self</code> (and extend to other type parameters)</a></h3>
<p>Analyze the types of methods within the trait definition. It a GAT is applied to a lifetime <code>'x</code>, examine the implied bounds of the method for bounds of the form <code>T: 'x</code>, where <code>T</code> is an input parameter to the trait. If we find such bounds on all methods for every use of the GAT, then add the corresponding default.</p>
<p>Consider the <code>LendingIterator</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'a&gt;;

    fn next&lt;'b&gt;(&amp;'b mut self) -&gt; Self::Item&lt;'b&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Analyzing the closure body, we see that it contains <code>Self::Item&lt;'b&gt;</code> where <code>'b</code> is the lifetime of the <code>self</code> reference (e.g., <code>self: &amp;'b Self</code> or <code>self: &amp;'b mut Self</code>). The implied bounds of this method contain <code>Self: 'b</code>. Since there is only one use of <code>Self::Item&lt;'b&gt;</code>, and the implied bound <code>Self: 'b</code> applies in that case, then we add the default <code>where Self: 'a</code> to the GAT. </p>
<p>This check is a fairly simple syntactic check, though not necessarily easy to explain. It would accept all the examples that appear in this document, including the example with <code>fn default() -&gt; Self::Data&lt;'static&gt;</code> (in that case, the default is not triggered, because we found a use of <code>Data</code> that is applied to a lifetime for which no implied bound applies). The only case where this default behaves <em>incorrectly</em> is the case where all uses of <code>Self::Data</code> that appear within the trait need the default, but there are uses outside the trait that do not (I couldn't come up with a realistic example of how to do this usefully).</p>
<h4 id="extending-to-other-type-parameters"><a class="header" href="#extending-to-other-type-parameters">Extending to other type parameters</a></h4>
<p>The inference can be extended naturally beyond <code>self</code> to other type parameters. Therefore this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser&lt;Input&gt; {
    type Output&lt;'i&gt;;

    fn get&lt;'input&gt;(&amp;mut self, i: &amp;'input Input) -&gt; Self::Output&lt;'input&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>would infer a <code>where Input: 'i</code> bound on <code>type Output&lt;'i&gt;</code>.</p>
<p>Similarly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Parser&lt;Input&gt; {
    type Output&lt;'i&gt;;

    fn get(&amp;mut self, i: &amp;'input Input) -&gt; Self::Output&lt;'input&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>would infer a <code>where Input: 'i</code> bound on <code>type Output&lt;'i&gt;</code>.</p>
<h4 id="avoiding-the-default"><a class="header" href="#avoiding-the-default">Avoiding the default</a></h4>
<p>If this default is truly not desired, there is a workaround: one can declare a supertrait that contains just the associated type. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait IterType {
    type Iter&lt;'b&gt;;
}

trait LendingIterator: IterType {
    fn next(&amp;mut self) -&gt; Self::Iter&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>This workaround is not especially obvious, however.</p>
<h4 id="related-precedent"><a class="header" href="#related-precedent">Related precedent</a></h4>
<p>We used to require <code>T: 'a</code> bounds in structs:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Foo&lt;'a, T&gt; {
    x: &amp;'a T
}
<span class="boring">}
</span></code></pre></pre>
<p>but as of <a href="https://rust-lang.github.io/rfcs/2093-infer-outlives.html">RFC 2093</a> we infer such bounds from the fields in the struct body. In this case, if we do come up with a default rule, we are essentially inferring the presence of such bounds by usages of the associated type within the trait definition.</p>
<h2 id="recommendation"><a class="header" href="#recommendation">Recommendation</a></h2>
<p>Niko's recommendation is to use the &quot;smart defaults&quot;. Why? They basically always do the right thing, thus contributing to <a href="https://rustacean-principles.netlify.app/how_rust_empowers/supportive.html">supportive</a>, at the cost of (theoretical) <a href="https://rustacean-principles.netlify.app/how_rust_empowers/versatile.html">versatility</a>. This seems like the right trade-off to me.</p>
<p>The counterargument would be: the rules are sufficiently complex, we can potentially add this later, and people are going to be surprised by this default when it &quot;goes wrong&quot; for them. It would be hard, but not impossible, to add a tailored error message for cases where the <code>where T: 'b</code> check fails.</p>
<p>Not sure about Jack's opinion. =)</p>
<h2 id="appendix-a-ruled-out-alternatives"><a class="header" href="#appendix-a-ruled-out-alternatives">Appendix A: Ruled out alternatives</a></h2>
<h3 id="special-syntax"><a class="header" href="#special-syntax">Special syntax</a></h3>
<p>We could use the <code>'self</code> &quot;keyword&quot;, permitted only in GATs, to indicate &quot;a lifetime with the where clause <code>where Self: 'self</code>&quot;. The <code>LendingIterator</code> trait would therefore be written</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait LendingIterator {
    type Item&lt;'self&gt;;

    fn next(&amp;mut self) -&gt; Self::Item&lt;'_&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Forwards compatibility note:</em> This option could be added later; note also that <code>'self</code> is not currently valid.</p>
<p><strong>Why not?</strong> <code>'self</code> is an awfully suggestive syntax. It may be useful for things like self-referential structs. This just doesn't important enough.</p>
<h3 id="force-people-to-write-where-self-a"><a class="header" href="#force-people-to-write-where-self-a">Force people to write <code>where Self: 'a</code></a></h3>
<p>To buy time, we could force people to write <code>where Self: 'a</code>, so that we can later allow it to be elided. This unfortunately would eliminate a number of valid use cases for GATs (though they would later be supported).</p>
<p><strong>Why not?</strong> Rules out a number of useful cases.</p>
<h3 id="dumb-default-always-default-to-where-self-a"><a class="header" href="#dumb-default-always-default-to-where-self-a">Dumb default: Always default to <code>where Self: 'a</code></a></h3>
<p>The most obvious default is to add <code>where Self: 'a</code> to the where clause list for any GAT with a lifetime parameter <code>'a</code>, but that seems too crude. It will rule out all existing cases unless we add some form of &quot;opt-out&quot; syntax, for which we have no real precedent.</p>
<p><strong>Why not?</strong> Rules out a number of useful cases.</p>
<h2 id="appendix-b-considerations"><a class="header" href="#appendix-b-considerations">Appendix B: Considerations</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/87479#issuecomment-890111937">How 'obvious' are the rules?</a></li>
</ul>
<h2 id="appendix-c-other-examples"><a class="header" href="#appendix-c-other-examples">Appendix C: Other examples</a></h2>
<h3 id="example-ruma"><a class="header" href="#example-ruma">Example: Ruma</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Every endpoint in the Matrix REST API has two request and response types in Ruma, one Incoming
// (used for deserialization) and out Outgoing (used for serialization). To avoid annoying clones when
// sending a request, most non-copy fields in the outgoing structs are references.
//
// The request traits have an associated type for the corresponding response type so things can be
// matched up properly.
pub trait IncomingRequest: Sized {
    // This is the current definition of the associated type I'd like to make generic.
    type OutgoingResponse: OutgoingResponse;
    // AFAICT adding a lifetime parameter is all I need.
    type OutgoingResponse&lt;'a&gt;: OutgoingResponse;

    // Other trait members... (not using Self::OutgoingResponse)
}
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://docs.rs/ruma-api/0.17.1/ruma_api/trait.IncomingRequest.html">full definition</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../design-discussions/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../design-discussions/where-the-where.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../design-discussions/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../design-discussions/where-the-where.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
